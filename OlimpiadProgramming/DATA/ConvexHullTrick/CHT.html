<!DOCTYPE HTML>
<!--
	InnoCalc
	p.s. Egor U
-->
<html>

	<head>

		<meta http-equiv="Content-Type" content="Plus/html; charset=utf-8">
		<link rel="stylesheet" href="../../style.css">
		<link rel="stylesheet" href="../../gorizoNav.css">
		<link rel="stylesheet" href="../../verticalNav.css">

		<style type="text/css">
		   #CHT
		   { 
		    background-color: #009d4b;
		   }
  		</style> <!-- Выделение навигации-->

	</head>


	<body>

	<?php
		include('../nav.php'); // включает навигацию
	?>




	<br></br>
	<div class = "Text"> <Biggreen>Convex Hull Trick</Biggreen> <br></br><br></br>

			
			Convex Hull Trick - метод оптимизации динамического программирования, использующий идею выпуклой оболочки. Позволяет улучшить асимптотику решения некоторых задач, решемых методом динамического программирования, с O(n<sup>2</sup>) до O(n*log(n)).<br></br>

			Пример задачи, решаемой методом convex hull trick :<br></br>

Есть n деревьев с высотами a<sub>0</sub>,...,a<sub>n-1</sub>. Требуется спилить их все, потратив минимальное количество монет на заправку бензопилы. Но пила устроена так, что она может спиливать только по 1 метру от дерева, к которому ее применили. Также после срубленного метра пилу нужно заправлять, платя за бензин определенной кол-во монет. Причем стоимость бензина зависит от срубленных полностью деревьев. Если сейчас максимальный индекс срубленного дерева равен i, то цена заправки равна c<sub>i</sub>. Изначально пила заправлена. Также c<sub>n-1</sub>=0, a<sub>0</sub>=1, a<sub>i</sub> возрастают, c<sub>i</sub> убывают.<br></br>

<green>Решение за O(n<sup>2</sup>):</green> для каждого i от 0 до n-1 , dp<sub>i</sub> равна минимальному <green>c<sub>j</sub>*a<sub>i</sub> + dp<sub>j</sub></green>, где j = 0...i-1.<br></br>

<green>Решение за O(n*log(n)):</green> <br></br>

Можно заметить, что уравнение <green>dp<sub>i</sub> = min(c<sub>j</sub>*a<sub>i</sub> + dp<sub>j</sub>)</green> похоже на уравнение прямой <green>y = k*x + b.</green> Тогда они будут иметь следующий вид:<br></br>
<img src="CHT.jpg" class = "scale" width="250px" height="150px"><br></br>

Пусть мы считаем динамику для i-го дерева. Его задает x<sub>i</sub>. Нам нужно для данного x<sub>i</sub> найти <green>min<sub>j=0...i−1</sub>(k<sub>j</sub>*x<sub>i</sub>+b<sub>j</sub>) = min<sub>j=0..i−1</sub>(y[j])</green>. Это выражение является нижней огибающей от x<sub>i</sub>. Отрезок, который пересекает прямую x = x<sub>i</sub>, можно найти бинарным поиском. Это потребует <green>O(log(n))</green> времени на поиск такого j, что <green>dp<sub>i</sub>=k<sub>j</sub>*x<sub>i</sub>+b<sub>j</sub></green>. Теперь осталось научиться поддерживать множество прямых и быстро добавлять i-ю прямую.<br></br>

Возьмём нижнюю огибающюю множества прямых на плоскости.<br></br>

Для этого воспользуемся идеей алгоритма построения выпуклой оболочки множества точек. Заведем стек S. Рассмотрим ситуацию когда мы хотим добавить новую прямую в множество. Пусть сейчас в стеке лежит Sz прямых. (xL , yL) - точка пересечения sz-1-й прямой множества и sz-й, а (xR , yR) - точка пересечения новой прямой и sz-й. Если оказалось, что новая прямая пересекает sz-ю прямую позже, чем sz-я sz-1-ю (xL ⩾ xR), то sz-ю удалим из нашего множество, иначе остановимся. Так повторяем пока количество прямых в стеке больше 2-х или xL ⩾ xR.<br></br>

<img src="goodLine.png" class = "scale" width="250px" height="150px">
<img src="badLine.png" class = "scale" width="250px" height="150px">  <br></br>


Асимптотика взятия множества огибающих прямых: каждая прямая ровно 1 раз добавится в стек и максимум 1 раз удалится. Значит время работы перестройки выпуклой оболочки займет <agreen>O(n)</green> суммарно.<br></br>

Добавим первую прямую. После чего для каждого i от 1 до n-1 будем бинарным поиском искать минимальный <green>y</green> и добавлять новую прямую в множество огибающих прямых.<br></br>

Ассимптотика <green>O(n*log(n))</green>.<br></br>

<a href="CHT.cpp" style = "text-decoration: none;">Код</a><br></br>

Задача: Калила и Димна на лесозаготовках.


	<br></br><br></br><br></br><br></br>
	
The end.


		</div>

	
	<!-- jQuery -->

	</body>
</html>

